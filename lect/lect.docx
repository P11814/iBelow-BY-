  С# язык со строгой типизацией 
  ССылочные и значимые:
  1) Значимые в стеке
  Простые типы данных
  Структуры
  Перечисления
  2) Ссылочные в куче =)
  Классы
  интерфейсы
  Массивы, строки, делегаты;
  
  
  Типы:
  Целочисленные, дробные, логические(булл)
  Целочисленные:
  sbyte, byte (1 байт памяти) {-128; 127}
  short, Ushort(2 байта) {-32768; 32767}
  Int, Uint (4 байта) {SsssS}
  Long, Ulong; (8 byte's)
  char ((sybol type) 2 bytes (Unicode +));
  
  
  Дробные:
  float (7 после запятой)
  double (15-16 после запятой)
  decimal (28-29 после запятой)
  
  Логические:
  Bool (1 byte);
  -------------------------------------------
  
  ЛИТЕРАЛЫ
  Это фиксированное значение, которое представленно в понятной форме, или по другому - константное значение.
  Все литералы имеют тип
  Для отнесения литерала к определенному типу - определено неск. правил:
   1)  Для целочисленного литерала назначается наименьший целый тип, позв. его хранить.
   2)  Все дробные значения имеют тип даббл
   3)  Для явной спецификации типа предусмотрен спец символ - L, F, D, M, U;
   L - Long
   F - Float
   D - double
   M - Decimal
   U - Unsigned
   
          
  В отдельную группу литераллов выделена последовательность (Escape) ((символьная последовательность)) \a
  
  Строковые литералы - выражаются в двойных ковычках
  для того, что бы строка воспринимаалась буквально(упр символы не работали) - перед стр. константой ставится значок @.
  
  
  
  ПЕРЕМЕННЫЕ:
  
  !!!!!!!!!!!!!!!!!! 
  
  Не явно типизированные типы: 
       var x = 7;, var y = 8.5, var z = 8.3F;
       Не явно тип. переменная задается var и должна быть сразу проинициализированна );
          нельзя явно преобразовать логический тип в явный, и наоборот -)
          нет авто-преобразования символьного типа в целый.
          
  
  
  ________Рандомчикиииии______________
       класс рандом Random(std:: System), который для вычисления нач. числа последовательности случ. числел
       использует системное время
       Random r = new Random;
       r.Next(); 0  RandMax;
  
  
       Массивы
       
   ТИП[размер] имя = new ТИП[размер];
   массив в Сишарп является ссылочным типом данных. те размещается в дин. памяти
   Размерность массива может задаваться переменной.
   ! псоле выделения памяти все элементы массива обнуляются автоматически.
   Размерность массива должна совпадать с колвом элементов в массиве.
                           int[] Arr = new int[256];
                           
       char[,] arr = new char[2,3];
       
           Рваные массивы;
  int[][] arr = new int [3][];
  arr[0] = new int[4]{1,2,3,4};
  arr[1] = new int[2]{0,1};
  
  
               1   2   3   0
               0   2
               0   0   0
  если двумерный массив можно предсттавить ввиде таблицы - то рваный массив можно определить как массив, строки которого могут иметь различную длинну
  рваные массивы объявляются с помощью двух кв.скобок.
  доступ к елементу рваного массива осущ. через указание индекса строки м столбца в кв. скобках!_)
   Выход за пределы массива, или обращение к несуществующему элементу приводит к ошибоньке
   Компилятор такие ошибки не отслеживает (
   
  
       особенности работы с массивами
           Тк массив С# Ссылочный, то он представлен объектом класса Array
       1. Свойство Length возвращает кол-во элементов, которое способен хранить массив.
           for(int i=0; i<arr.length; i++) {};
           В двумерном возвращается кол-во всех массивов;
           |Length для рваного массива возвращает колво строка, а при обращении к каждой строке возвращает кол-во элементов в строке.
       2. Присовение массивов друг другу:
           При копировании одного массива в другой - онми будут ссылаться на один участок памяти.
           Для поверхностного копирования массивов юзается метода clone (copy);
           Clone создает новый массив, а COPY требует наличие сущ массива той же размерности
           
  
  
  
           foreach(тип, ит.начала, ит.конец){
           Тип итератора должен совпадатьс типом элемента в коллекции
           }
  
           МОЖНО ТТОКА ВЫВЕСТИ ЭЛЕМЕНТА МАССИВА, ИЗМЕНИТЬ ИХ НЕЛЬЗЯ(
           для многомерных массивов все элементы выводятся линейно.
  
  
           Строки в шарпе представленны классом String и являются ссылочными или объектными
           
           Создание строк
           
           strint str1 = "Простая строка";
           char[] ctr1 = {'A', 'B',...};
           string str2 = new string(ctr1);
           string str3 = new string(ctr, 8, 6);
           string str4 = new string('$', 10);
           
           2. ToString();
           int x = 7;
           string s = x.ToString();
           
  
  
  
           РАБОТА СО СТРОКАМИ
           1. Длина строки определяется свойством Length. Вернется кол-во символов
           2. К каждому символу можно обратиться по индексу
           3. Через индекс нельзя изменить символ строки
           4. Строки типа стринг не изменны.
           5. Для объединения строк используется символ "+"
           6. Строки юзаются в конструкции switch
           7. строки могут быть объеденены в Массив =)
           8. Для стравнения строк исп оператор = или !=, и проверяет равенство содержжимого двух строк
           9. Основные методы для работы со строками:
               
  
  
               26.02.2015 
               В отличии от строк  типа String, строки типа StringBuilder являются изменяемыми, но имеют меньшее кол-во возможностей по раборте со строками
               Строки типа string при создании выделяют столько памяти, сколько необходимо для хранения строки
               Сроки типа StringBuilder выделяют изначально память в 16 символов, а если больше, то удваиваются. Для создания строки след синтаксис:
                   StringBuilder str = new StringBuilder("Привет братуха, как житуха", 120);
                  Строка имеет два свойства: Length, Capacity/длина, емкость
                  // Длинна показывает на дл. строки в объекте в данный момент
                  // Емкость - макс. длинна строки, которая может поместиться в выделенную для объекта память/
                  
           Основые методы:
               Append() - добавляет строк к текущей строке;
               AppendFormat() - Добавляет форматированную строку к текущей строке
               Insert() - вставляет подстроку в строку
               Remove() - удаляет символ из текущей строки
               Replace() - Замена символа в строке
               ToString() привести строку StringBuilder к String, и наоборот
               
  
  
  
  
               Классы
               доступ: protected, public, private;
               class NameClass{
                   //<body>
                   //Поля класса
                   public string Name, LastName, Adress;
                   public byte age;
                   //Метод, выводящий в консольку КД
                   public void WriteInConsoleInfo(string name, string lastname, adress){
                   
                           }
               }
               
       
               //UserInfooo myinfo = new Userinfooo();
               При копировании переменных происходит перенос значенийЮ, а при копировании обхъектов перенос адресов(они будут указывать на одну и ту же область памяти)
               
               Инициализация объекта:
               new имяКласса{имя = выражение, имя = выражение,...};
               autoCar myCar = new autoCar{marka = "Renault", year = 2004};
               
           Если метод ничего не возвращает, то тип возвр. значения - void.
           В пределах одного класса сигнатуы методов не повторяются
           фактические параметнры метода являются локальными по отношению к методам, и уничтожаются после выхода из метода
  
           передача аргументов по ссылке и по значению:
           при класической передаче аргументов в метод используется передача по значению.\
           т.е. переданные аргументы копируются и становятся наоборот по отношению к методу.
           Если из метода необходимо вернуть более одного значения, то в такой метод необходимо передовать аргументы по ссылке.
           для передачи по ссылке модификаторы ref и out/
            должны указываться как при передаче аргументов, так и в списке параметров метода.
           переменные, передоваемые с моdификатором ref должны быть проинициализированны при передаче. могут не имeть инициализации, но внутри метода должны быть проинициализированны.
           В методе параметр out считается не проинициализированным.
           
               Модификатор params // кл. слово params - позволяет передовать метод переменное кол-во одного типа ввиде единственного логического параметра.
               В качестве аргумента в метод с можификатором params может быть передан как отдельный массив, так и множество однотипных элементов, ПЕРЕЧИСЛЕННЫХ через ',';
               если метод принимает несколко параметров, одним из котрых является params, то параметр с params должен идти в списке последним_)
               В списке параметров метожа может присутствовать только один параметр с модификатором params.
  
  
           _______________02.03.2015______________
           
  
           Необязательные и именнованные аргументы
      Необязательные аргументы необходимы для того, что бы использовать по умолчанию значения для некоторых параметров методов.
      Необязятельные аргументы указываются в конце списка параметров через знак "=" и присвоения значения по умолчанию.
       Именнованные аргументы.
       предназначены для передачи в метод любой последовательности. При передаче необходимо указать имя параметра, двоеточие и его зачение
  static int mySum(int a, int b, int c){
   return a+b+c;
  }
           int sum = mySum(a: 3, b: 10);
       
  
  
               конструктор
               это метод класса, предназначенный для инициализации объъекта при создании, который иммет такое же имя, как имя класса, ничего не возвращает, может принимать неогр. число параметров.
               чаще всего используется с "public". Каждый класс снабжается конструктором по умолчанию(без параметров). его можно переопределить.
               
                   !!! При создании конструктора с параметрами - конструктор без параметров (по умолчанию) затирается!!!!
                   пожтому при создании пользовательских надо пересоздвавать конструктор без параметров.
  
  
                   Деструктор
                       Это метода, который выхывается автоматически перед удалением объекта из памяти. имееет такое же имя/, как и имя
                       класса, ничего не возврващает, перед ним используется знак "~".
                       
  
                               Ключевое слово "this"
                               обеспечивает доступ к текущему объекту. использование this:
                                   1. для разрешения неоднозначностьи контекста.
                                   class myClass{
                                   public char ch;
                                   public void Method1(char ch){
                                       this.ch = ch
                                       }
                                   }
                                   
                                   2. Сцепление конструкторов
                                       используется, когда имеется класс, определяющинй несколько конструкторов,
                                       и в каждом им конструкторов необходимо делать однотипные проверки на инициализацию полей.
                                       Поэтому для предотвращения избыточной проверки один конструктор сможет выхывать другой.
                                       очередность вызова окнструктора в цепочке
                                       
                                       К1(парам) : this(парам1, парам2){
                                       Тело К1;
                                       }
                                       
  
  
                                       Статические элементы классы
                                       
                                               1. Статический элмент класса юзается на уровне класса, нехависимо от объектов этого класса.
                                                   Статические элементы объявляются с помощью "static":
                                                   
                                                   Статические поля (типа глобальные поля)
                                                   
                                                   Все объекты класса совместно используют статическую переменную
                                                   для доступа к ст. переменной используется ИМЯ_КЛАССА.ИМЯ_ПЕРЕМЕННОЙ
                                                   
                                       class Planet{
                                           private static int Count;
                                           public Planet(){
                                               Count++;
                                               }
                                           }
                                           
  
                                               2. Статические методы
                                                       используются на уровне класса. и используются.
                                                       стат. методы могут обращаться тоьлко к статическим переменным и методам данного класса.
                                                       Не может использоваться ссылка this
                                               3. @ Статические конструкторы используется для инициализации компонентов, применяемых ко всему классу. т.е. для статических
                                               Вызывается автоматически при первом обращении к имени класса.
                                               4. Статические классы   перед классом static. должен содержать только статические члены. объект стачического класса создать низзя.
                                               стат. классы используются в основном для хранения совокупности связанных друг с другом стат. методов.
  
  
  
                                           ЧАСТИЧНЫЕ ТИПЫ
                                                     Если необходимо разбить класс на неск. файлов в рамках одного пространства имен, то перед словом class указывается слово partial
                                                     public partial class NAME{}
                                                     
                                           _______________Исключительные ситуации.
                                           Представлен классом exception, и его производными. каждый класс описывает конкретную, искслючительную ситуацию.
                                           для работы с исключениями используются try, cathc, finally.
                                           try{
                                           <operator1>
                                           ...
                                               }
                                           
                                           catch([<type> [<name>]]){
                                               <operator1>
                                               }
                                               
                                           finally{
                                           <operator 1>
                                           ...
                                           }
                                           
                                          В блок финали помещается код, котторый будет выполнен, все зависимости от того, была ли сгенерированна исключительная ситуация 
                                          Чаще используется для освобождения различных ресурсов
                                          Порядок обработки исключений:
                                          Вход в блок try
                                          если иск. ситуации не возникло, то переход к блоку finally, а если его нет - то к инструкции, следующей за последним блоком catch.
                                          Если сит. возникла в try, то -> к соотв. блоку cathc, если в catch нету выхода из метода - то далее переход к инструкции после всех блоков cathc.(либо к finally)
                                          при наличии блока finally его выполнение, и переход к инструкции после finally
                                          исключения могут быть сгенерированны внутри метода, который был вызван из блока try.
                                          если после блока try используется неск. блоков catch, то каждый должен обрабатывать свою искл. ситуацию.
                                          блок catch без параметров является универсальным, и срабатывает для всех типов ошибок. Его необходимо размещать последним.
                                          тк поиск соотв. блока обработки осуществляется поочередно.
                                          
  
                                           Вложенные блоки try, catch.
                                           один try блок можно вложить в другой.
                                           исключение, сгенерированное во внутреннем try блоке, не перехваченное внутренним cathc блоком - передается во внешний try блок.
                                           чаще всего используется для обработки различных категорий ошибок. во внутренние помещаются менее опасные ситуации, во внешние - более опасные ситуации.
  
  
  
  
                                               03.03.2015
                                           генерирование исключений вручную
                                           throw - инструкция, используется для генерации исключения вручную. После слова throw указываеттся объект опр. ситуации
                                           try{
                                           Console.Write("...");
                                           throw new FormatException;
                                               }
                                           catch(FormatException){
                                           .....}
                                           Для создания собственных исключений необходимо создать новый класс, унаследовать его от класса exception
                                           для генерации польз. искл. используем "throw";
                                           
                                           //-----------------------------------------------------
                                           catch (UserException err){
                                           Console.WriteLine(err.Message.ToString());
                                           }
  
  
  
                                           class UserException : Exception{
                                               public override string Message{
                                                   get{
                                                       return "UserException";
                                                       }
                                                   }
                                               }
                                           //------------------------------------------------------
                                               
  
                                           Повторное генерирование искюлчений:
                                           Исключения перехваченные одной catch инструкцией можно пере-генерировать, что бы обспечить возмодность его перехвата
                                           другой, внешней catch инструкцией. для этого используется слово throw.
                                           При повторном генерировании исключения - оно не будет повторно перехватыватся той же catch инструкцией, а передается 
                                           следующей catch инструкции
                                               свойства и методы классов исключительных ситуаций.
                                               exc.Message - вывод сабжа краша
                                               exc.StackTrace - выводит сабж со стеком вызовов, приведших к возникновению краша
                                               exc.TargetSite - Возвращает имя метода, сгенерировавшего исключение.
                                              !Для использования данных свойств необходимо в параметре блока catch не только тип исключения - но и имя объекта.
                                              Применение инструкции checked и unchecked
                                              используются для генерации исключения при возникновении переполнения.
                                              используются в двух формах:
                                                   1-ая - checked(<выражение>);
                                                          unchecked(<выражение>);
                                                   2-ая - checked {<блок>};
                                                          uncheked {<блок>};
                                                  
                                                      
                                                   byte a, b;
                                                   byte result;
                                                   a = 127;
                                                   b = 127;
                                                   
                                                   try{
                                                   result = checked((byte)(ab);
                                                   Console.WriteLine(result);
                                                   }
                                                   catch(OverFlowException err){
                                                   Console.WriteLine(exc.Message);
                                                   }
  
                                               //-------------------------------------------------------------
                                               Пространство имен:
                                                   это некая область объявки данных, которая обеспечивает логическую взаимосвязь типов
                                                   Пространство имен может быть вложено друг в друга.
                                                   В таком случае для доступа к внутреннему классу необходимо перечислить все имена пространств имен, начиная
                                                   сверху, через точку.
                                                   В рамках одного проекта может существовать неск. пространств имен.
                                                   если в одном файле сущ-ет два пространства имен - то области их видимости не пересекаются. Для того, что бы из
                                                   одного пространства к элементам второго класса - необходимо писать полный путь (Через точку).
                                                   Если два пространства имен указаны в операторах using содержат тип с одинаковым именем - то необходимо использовать полную форму имени.
                                                   Одно пространство имен может быть разбито на части в рамках одного файла.
                                                   Вторая форма using
                                                   может применятся не тока для пространства имен, а так же для созания псевдонимов
                                               //-------------------------------------------------------------
                                               
  
  
  
  
  
  
                                                   04.03.2015
                                                   
                                               перегрузка операторов
                                               
                                       Требования к перегрузке операторов
                                       Перегрузка операторов позволяет указать, как стандартные операторы будут использоваться с объектами класса.
                                       перегрузка операторов болжна выполняться статическими методами класса
                                       параметры перегружаемого метода не должны включать модификаторы out и ref
                                       У перегружаемого метода тип значения (или тип одного из параметров) должен совпадать с типом, в котором выполняется перегрузка.
                                       невозможно изменить значения стандартных операций для стандартных типов данных.
                                       Ограничения на перегрузку:
                                           перегрузка не может изменять приоритет операторов.
                                           перегрузка не может изменять кол-во операндов, с которым работает оператор.
                                           Операторы, не допускающие перегрузку:
                                               +=, -+, =, =, !=, >>, ., ?:, new, as, is, typeof, sizeof;
                                              перегрузка унарных операторов:
                                              
                                              public static <тип возвр. значения> operator <symbol> (<тип параметра операнд1>);
                                              
                                              Тип операнда должен совпадать с классом
                                              Перегрузка постфиксной и префиксной отдельно не выделяется.
                                               Оператор "-" не должен изменять состояние текщего объекта, а должен возр. новый объект с изм. знаком.
                                      ___перегрузка бинарных операторов:
                                      Хотя бы один из типов операндов должен совпадать с тем, для которого перегружается оператор
                                      При применении бинарных операция для объекта и встроенных типов данных - важен порядок следования операндов.ъ
                                      a+10 и 10+a должны иметь два перегруженных метода.
                                      
  
                                      Оператор отношений:
                                      Операторы отношений перегружаются парами.
                                      ><, >= <=, == !=;
                                      как правило, перегруженный оператор отношения возвращает логическое отношение true false.
                                      перегрузка операторов true false. надо перегружать в паре.
                                      --------05.03.2015
                                      перегрузка логических операторов:
                                      (и/или/не)       перегруженный логискиеи опраторы должны возвращать bool
                                      (&  |  !)/Для перегрузки сокращащенных логическиз операторов нужно учесть дополнительные перегрузки.
                                      Для перегрузки логических опреаторов, работающих по сокращенной схеме - необходимо перегрузить операторы и/или/
                                      перегруженные побитовые операторы должны возвращать объект класса, для которого перегружаются эти операторы.
                                      Каждый параметр должен быть сссылкой на объект класса.
                                      Необходимо перегрузить операторы true/false.
                                      перегрузка операторов преобразования.
                                      Явное
                                      public static explisit operator type_result(source_type v){
                                      return value;
                                      }
                                      не-
                                      public static implicit operator type_result(source_type v){
                                      return value;
                                      }
                                       
                                      В одном классе нельзя делать явное и не явное преобразование.
                                      1+2=3
                                      3=1+2+3
                                      3=6
                                      
  
  
                               Свойства и индексаторы:
                               Свойства предназначены для организации доступа к закрытым полям класса.
                               Заменяют открытые методы
                               могут иметь accessors set & get, в каждом из которых осуществляются проверки присвоения и возвращения результатов переменной
                               для которой было созданно свойство.
                               private int size;
                               public int size{
                                   get{return size};
                                   set{size = value};
                                   }
                               Особенности работы со свойствами:
                               
                               1. Свойства могут содержать только один accessors: get || set || get & set;
                               2. Свойство не может быть перегруженно.
                               3. Не может быть переданно в  метод с параметром ref или out;
                               4. Свойство не должно изменять значение переменной в <get>
                               5. Свойства могут быть статическими.
                               6. Один из аксцессоров доступа может иметь различные спецификаторы доступа. Второй акц должен обязательно иметь спец-р доступа соответствующий свойст
                               Автоматические свойства:
                               для полей класса можно создавать автьматические свойства, т.е. записывать акц гет и сэт без тела.
                               1. Поддерживающие переменные создаются автоматически
                               2. Проверка достоверности вводимых данных в методе set не может быть выполнена.
                               3. Должны присутствовать оба метода доступа.
                                
                               
  
                               Сокрытие членов производных от базового класса
                               base - обращение к сокрытым членам класса.
                                   Сокрытие имен при наследовании: 
                                       Производный класс может определить член, имя которого совпадает с именем базового класса.
                                       В этом случае член базового класса становится скрытым в производном классе.
                                       Данная ситуация не вызовет ошибки, а только предупреждение, для предотвращения которого необходимо указать ключевое слово new перед членом производного класса.
                                       Скрывать модно не только переменные, но и методы, свойства, и т.д.
                                       для доступа к скрытым элементам базового класса из производных используется слово "base."
                                   Использование ссылок базового класса на приозводном:
                                   Объект одного класса не может быть присвоен объекту другого класса, за искл. того, если они находятся в иерархии наследования
                                   ССЛЫКИ БАЗОВОГО КЛАССА МОЖНО ПРИСВОИТЬ ОБЪЕКТ ЛЮБОГО ПРОИЗВОДНОГО КЛАССА.
                                   class X{
                                       int a;
                                       }
                                   class Y:X{
                                       int b;
                                       X x1 = new y();
                                       x1.a =3;
                                       x1.b = 4; //error
                                       }
                                           
                                   Тип ссылочной переменной, а не тип объекта, на который она ссылается - определяет какие члены могут быть доступны.
                                   Чаще всего ссыллки типа "базовый класс на производный" используютс при создании универсальных методов, которые принимают ссылки базового класса, а передоватьв них можно
                                   объекты производных классов
                                   Виртуальные методы:
                                   Виртуальным называется метод который объявляется с помощью virtual в базовом классе, и переопределяется в одном или неск. производных классов с помощью override.
                                   виртуальные методы имеют смысл, когда они вызываются через ссылку на базовый класс
                                   !!!!ТИП ОБЪЕКТА, НА КОТОРЫЙ УКАЗЫВАЕТ ССЫЛКА, (А НЕ ТИП ССЫЛКИ) ОПРЕДЕЛЯЕТ, КАКАЯ ВЕРСИЯ ВИРУТАЛЬНОГО МЕТОДА БУДЕТ ВЫПОЛНЕНА
                                   ПРИ ПЕРЕОПРЕДЕЛЕНИИ ВИРУТАЛЬНОГО МЕТОДА СИГНАТУРЫ ВИРТУАЛЬНОГО И ПЕРЕОПРЕДЕЛЕННОГО ДОЛЖНЫ СОВПАДАТЬ.
                                   ЕГО НЕльзя определять, как статический.
                                   переопределение виртуальных методов является основой динамической диспетчерезацией методов\
                                   Это мех-м вызова переопределенного метода во время выполнения программы (а не в переиод компиляции)
                                   виртуальными могут быть и свойства.
                                   Если виртуальный метод переопределяет виртуальный метод в многоуровневой иерархии - то будет выполнен первый переопределенный метод, 
                                   который обнаружится при просмотре иерархической лестнице снизу вверх.
                                      			Абстрактные классы и методы:
		
	Иногда виртуальный метод в базовом классе не может иметь реализацию. В таком случае используется абстрактные методы.
Абстрактный метод объявляется через ключевое слово abstract, не имеет тела, и в конце заголовка ставиться “ ; ”.
Если виртуальный метод может быть не переопределен в производном классе – то абстрактный метод должен быть обязательно переопределен в производном классе с помощью override. Абстрактный метод – есть виртуальный, поэтому virtual & abstract – совместно не допустимо. Абстрактные методы не могут быть статическими. Если в классе определен хотя бы один абстрактный метод – то такой класс отмечается как abstract. Объекты абстрактного класса создавать нельзя.
	Если абстрактный метод всё же не переопределен в производном классе – то такой класс так же должен быть помечен, как абстрактный.
	Могут быть не только методы  - но и свойства.
		Объект абстрактного класса создавать нельзя – но можно создать ссылку типа «абстрактный класс», которая будет указывать на объекты производных классов.
	Использование Sealed (нельзя от наследоваться)
	Используется перед именем класса для того, что бы предотвратить наследование от него
Так же позволяет «запечатывать» переопределенные методы.
	
Правила приведения к базовому и производному классу
1)	Когда два класса связанны отношением наследования – всегда можно безопасно сохранить объект производного класса в ссылке базового класса (неявное приведение). В « .Net» конечным базовым классом является класс object. И все созданные классы неявно наследуются от object. -> объект любого класса можно сохранить в ссылке типа object
2)	Необходимо явно выполнять приведение вниз, т.е. от более общего к более частному, используя опрецию приведения «(класс_к_которому_приводим) объект_который_приводим»
КЛАСС OBJECT – ВЛАДЫКА ВСЕХ КЛАССОВ.
Явное приведение используется:
1.	Для доступа к членам производного класса при обращении через ссылку базового класса:
Shape s  = new Triangle;
((Triangle) s).Style =” ”;
2.	При передаче в метод ссылки базового класса на производный, если метод принимает объект производного класса:
object T3 = new Triangle();
	public static void Show(TwoDShape s){
		}
/Явное приведение происходит во время выполнения, а не во время компиляции -> существует вероятность неправильного приведения типов. Для проверки на правильность используется 3 варианта:
1.	Включить в блок try строку с явным приведением
2.	Использование ключевого слова as. Операция as возвращает либо ссылку на новый приведенный объект, либо null, если типы не приводятся:
Director D1 = new Director();
Triangle T1 = D1 as Triangle;
3.	Операция is возвращает true, если типы приводимы, false – если не совместимы.
if(D1 is Triangle)
(Triangle)D1.some…
else{…}
			
					КЛАСС OBJECT
Т.К.  object можно использовать в качестве обобщенного типа данных.
Можно создавать массив типа object 
Ссылка типа object может указывать на значимую переменную, т.е. происходит перенос значений из стека в кучу. Такой процесс называется boxing(упаковка). Приведение к объектному типу осуществляется автоматически.
Int x; 		//стек
Object obj; 	// ссылочный в кучу
Obj = x; 	// boxing
Обратный процесс восстановления значимого типа из … называется распаковкой. Реализуется через явное приведение к явному типу
Int y = (int)obj; //unboxing
Int y (int) mas[0];
Класс object используется при описании типа параметров метода для придания им общности, а так же для хранения ссылок на объекты различного типа, таким образом реализуется полиморфизм. 
Класс object имеет следующие открытые методы:
1.	Equals (правда перегруженный) – сравнивает объект, для которого вызван метод с параметром метода, сравнивает объект с параметром метода на принадлежность к одной и той же области памяти.
2.	GetHashCode() -  формирует хеш-код объекта и возвращает число однозначно идентифицирующий объект. Можно переопределить(т.к. виртуальный метод).
3.	GetType – Возвращает тип объекта, на который указывает ссылка.
4.	ToString() – Виртуальный метод, который для ссылочных типов возвращает имя класса в виде строки, а для значимых – значение в виде строки/
5.	ReferenceEquals() – возвращает true, если оба параметра ссылаются на одну и туже область памяти





ИНТЕРФЕЙСЫ
Интерфейс определяет набор функций членов, которые будут реализованы классом-наследником. Сам интерфейс функции-члены не реализует. Один класс может наследовать несколько интерфейсов (множественное наследование). И один интерфейс может наследоваться несколькими классами, кроме того ИФ могут наследоваться друг от друга.
Синтаксис:
	[<attributes>] [<specifications>] interface name_of_interface [:parent’s]{
		<TODO>
	}


В ИФ не  могут содержаться поля, конструкторы\деструкторы, и перегрузка операторов.
В ИФ все элементы являются открытыми <public>. Нельзя менять. Это unreal;
Указываются только тип возвращаемого значения, имя члена, список параметров.
Не может быть статическим.
Реализация:
	При наследовании интерфейса после « : » указывается имя базового класса, и далее, через « , » имена всех интерфейсов – предков. 
Сигнатуры должны совпадать в ИФ и классе (имена, аргументы). Методы, которые реализованы в классе из интерфейсов, должны быть открыты. 
В классе, кроме методов, реализованных из ИФ можно создавать дополнительные члены. 
ЧИ реализованные в классе, могут создаваться виртуальными или абстрактными, но не статическими или константными.
При реализации ИФ перед реализуемым членом можно указать имя интерфейса, в таком случае метод становится закрытым, и доступ к нему будет осуществляться через явное приведение.
Если класс реализует ИФ, унаследованный от другого ИФ, то в классе должны быть реализованы методы двух ИФ.

ИФ Ссылки
Точно так же, как можно создавать ссылки типа «базовый класс» и указывать их на производные – можно создавать и интерфейсные ссылки, которые будут указывать на объекты классов, реализующих данный ИФ.
!!! НЕЛЬЗЯ СОЗДАВАТЬ ОБЪЕКТЫ ИНТЕРФЕЙСОВ!!!
iPointy p = new iPointy();
ИФ ссылка предназначена для обращения к методам, реализованным из ИФ, для обращения к собственным полям и методам класса, нужно делать явное приведение. При вызове метода через ИФ ссылку будет выполнен тот метод, на объект которого указывает ссылка.
предположим, что создан массив типа Shape, который содержит объекты классов, причем некоторые поддерживают ИФ iPointy, а некоторые не поддерживают. Для определения во время работы программы, поддерживает ли объект ИФ, используется несколько способов:
1.	Явное приведение объекта к интерфейсу, и заключение этой операции в блок try.
2.	Использование as
3.	Использование is


Использование интерфейсов в качестве параметров:
Методы могут принимать ИФ ссылки, что позволяет принимать в такие методы объекты различных типов, не связанные между собой, кроме как ИФ-ми. 
ИФ ссылки можно возвращать из методов.
При наследовании класса от неск. ИФ сущ-ет вероятность совпадения имен методов в этих ИФ. В таком случае в классе название реализуемого метода необходимо предварять именем ИФ с точкой. Указывать спец. Доступа для такого не требуется, т.к. автоматически он приватный -> доступ к такому члену будет осуществляться через явное приведение объекта класса к соотв. ИФ ссылке
Стандартные ИФ

